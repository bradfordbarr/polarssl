#!/usr/bin/env node

var fs = require('fs');
var minimist = require('minimist');
var sprintf = require('sprintf-js').sprintf;

function usage(code, message) {
  var log = (code) ? console.error : console.log;
  if (message) { log(message); }
  log('usage: openssl2c [OPTIONS]');
  log('  -h, --help\t\t\tDisplays this message');
  log('  -f, --file <file>\t\tInput key file in plain text form (defualt: STDIN)');
  log('  -o, --out <file>\t\tOutput file (defualt: STDOUT)');
  process.exit(code);
}

function parse(data) {
  var headerMapping = {
    'modulus': 'N',
    'Modulus (512 bit)': 'N',
    'publicExponent': 'E',
    'Exponent': 'E',
    'privateExponent': 'D',
    'prime1': 'P',
    'prime2': 'Q',
    'exponent1': 'DP',
    'exponent2': 'DQ',
    'coefficient': 'QP'
  };
  var lines = data.split('\n');
  var line = lines.shift();
  var data = {};

  function getKey(line) {
    if (/^\s+/.test(line)) {
      return null;
    }
    return line.split(':')[0].trim();
  }

  function getPublicExponent(line) {
    return new Buffer(('0' + /\(0x(.*)\)/.exec(line)[1]), 'hex');
  }

  function isKey(key) {
    return (headerMapping[key] === undefined) ? false : true;
  }

  function isData(line) {
    return (/^\s+/.test(line) && line !== '');
  }

  function hexToBuffer(str) {
    return new Buffer(str.replace(/:/g, ''), 'hex');
  }

  while(lines.length > 0) {
    var key = getKey(line);
    if (isKey(key) && (key === 'publicExponent' || key === 'Exponent')) {
      data[headerMapping[key]] = getPublicExponent(line);
    } else if (isKey(key)) {
      var item = '';
      line = lines.shift();
      while (isData(line)) {
        item += line.trim();
        line = lines.shift();
      }
      data[headerMapping[key]] = hexToBuffer(item);
      continue;
    }
    line = lines.shift();
  }

  return data;
}

function output(data) {
  var output = '/** THIS FILE WAS AUTOGENERATED BY openssl2c **/\n#include <stdint.h>\n\n';
  var define = 'uint32_t %s_LENGTH = %d;\n'
  var header = 'uint8_t %s[] = {\n';
  var footer = '};\n\n';

  for (var prop in data) {
    var buffer = data[prop];
    var body = sprintf(define, prop, buffer.length);
    body += sprintf(header, prop);
    for (var i = 1; i <= buffer.length; i++) {
      body += sprintf("0x%02X,", buffer.readUInt8(i - 1));
      if (i % 16 === 0) body += '\n';
    }
    if (buffer.length === 3) body += '\n';
    body += sprintf(footer, prop, buffer.length);
    output += body;
  }

  return output;
}

function main() {
  var opts = {
    boolean: ['h', 'help'],
    string : ['f', 'file', 'o', 'out']
  }
  var args = minimist(process.argv.slice(2), opts);
  var help = args['h'] || args['help'] || false;
  var file = args['f'] || args['file'] || null;
  var out  = args['o'] || args['out']  || null;
  var fileStream = null;
  var fileData = '';

  if (help) {
    return usage(0);
  }

  if (out) {
    out = fs.createWriteStream(out);
  } else {
    out = process.stdout;
  }

  if (file) {
    try {
        fileStream = fs.createReadStream(file);
    } catch(e) {
      usage(1, e);
    }
  } else {
    fileStream = process.stdin;
  }

  fileStream.on('readable', function() {
    var chunk = fileStream.read();
    if (chunk !== null) {
      fileData += chunk.toString();
    }
  });

  fileStream.on('end', function () {
    out.write(output(parse(fileData)));
  });
}
main();
